- [Hướng Dẫn Vận Hành Và Giám Sát Oracle \& MongoDB](#hướng-dẫn-vận-hành-và-giám-sát-oracle--mongodb)
  - [Phần I: Oracle Database](#phần-i-oracle-database)
    - [1. Kiến Trúc Cốt Lõi](#1-kiến-trúc-cốt-lõi)
      - [1.1 Oracle Real Application Clusters (RAC)](#11-oracle-real-application-clusters-rac)
      - [1.2 Kiến Trúc Multitenant (CDB \& PDB)](#12-kiến-trúc-multitenant-cdb--pdb)
      - [1.3 Kết Hợp RAC Với Multitenant](#13-kết-hợp-rac-với-multitenant)
    - [2. Vận Hành Cơ Bản Trong Môi Trường RAC](#2-vận-hành-cơ-bản-trong-môi-trường-rac)
      - [2.1 Sự Khác Biệt Giữa Tài Khoản `oracle` và `grid`](#21-sự-khác-biệt-giữa-tài-khoản-oracle-và-grid)
      - [2.2 Các Câu Lệnh Vận Hành Chính và Tình Huống Sử Dụng](#22-các-câu-lệnh-vận-hành-chính-và-tình-huống-sử-dụng)
      - [2.3 Quy Trình Xử Lý Sự Cố Tiêu Chuẩn](#23-quy-trình-xử-lý-sự-cố-tiêu-chuẩn)
      - [2.4 Quy Trình Khởi Động (Startup) Một Cơ Sở Dữ Liệu RAC](#24-quy-trình-khởi-động-startup-một-cơ-sở-dữ-liệu-rac)
    - [3. Giám Sát Và Chẩn Đoán Hiệu Năng](#3-giám-sát-và-chẩn-đoán-hiệu-năng)
  - [Phần II: MongoDB](#phần-ii-mongodb)
    - [1. Kiến Trúc Sharding (Phân Mảnh)](#1-kiến-trúc-sharding-phân-mảnh)
    - [2. Vận Hành Và Giám Sát](#2-vận-hành-và-giám-sát)
      - [1. Quy Trình Import Dữ Liệu Vào Sharded Cluster](#1-quy-trình-import-dữ-liệu-vào-sharded-cluster)
      - [2. Giám Sát Với MongoDB Compass](#2-giám-sát-với-mongodb-compass)
  - [Phần III: Tổng kết](#phần-iii-tổng-kết)
    - [Checklist Hàng Ngày](#checklist-hàng-ngày)
    - [Công Cụ Hỗ Trợ](#công-cụ-hỗ-trợ)


# Hướng Dẫn Vận Hành Và Giám Sát Oracle & MongoDB

## Phần I: Oracle Database

### 1. Kiến Trúc Cốt Lõi

#### 1.1 Oracle Real Application Clusters (RAC)

Oracle RAC cho phép nhiều máy chủ (nodes) cùng truy cập vào một cơ sở dữ liệu duy nhất, mang lại tính sẵn sàng cao và khả năng mở rộng. Điều này đặc biệt hữu ích khi hệ thống cần hoạt động liên tục 24/7, giảm thiểu thời gian ngừng hoạt động (downtime) khi một node gặp sự cố, tăng khả năng xử lý song song và dễ dàng mở rộng quy mô.

```mermaid
graph TD
    subgraph "Clients/Application"
        A[App Server 1]
        B[App Server 2]
    end
    subgraph "Oracle RAC Cluster"
        N1[Node 1: Oracle Instance]
        N2[Node 2: Oracle Instance]
    end
    SS[Shared Storage <br> ASM Disks]
    A --> N1
    B --> N2
    N1 <-->|Cluster Interconnect| N2
    N1 --> SS
    N2 --> SS
    %% Styling
    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px,color:#000
    style B fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    style N1 fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    style N2 fill:#fce4ec,stroke:#c2185b,stroke-width:3px,color:#000
    style SS fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px,color:#000
```

**Giải thích sơ đồ:**
- **Node 1 & Node 2:** Mỗi node là một máy chủ vật lý hoặc ảo chạy một instance Oracle, xử lý các yêu cầu từ ứng dụng.
- **Cluster Interconnect:** Mạng riêng tốc độ cao để các node trao đổi thông tin (cache fusion, heartbeat). Nếu kết nối này chậm hoặc không ổn định, hiệu năng RAC có thể kém hơn so với một instance đơn lẻ.
- **Shared Storage:** Nơi lưu trữ dữ liệu chung, thường sử dụng Automatic Storage Management (ASM) để quản lý hiệu quả.

**Lưu ý quan trọng:** Đảm bảo Cluster Interconnect có độ trễ thấp để tránh ảnh hưởng đến hiệu suất tổng thể.

#### 1.2 Kiến Trúc Multitenant (CDB & PDB)

Kiến trúc này cho phép quản lý nhiều cơ sở dữ liệu độc lập trong một container chung, tiết kiệm tài nguyên hệ thống (CPU, RAM, storage), hỗ trợ triển khai nhanh chóng và tách biệt dữ liệu giữa các ứng dụng.

```mermaid
graph TD
    subgraph "Server"
        CDB["Container Database (CDB#36;ROOT)"]
        subgraph "Pluggable Databases (PDBs)"
            PDB1["PDB_HR <br> (Chứa dữ liệu Nhân sự)"]
            PDB2["PDB_SALES <br> (Chứa dữ liệu Kinh doanh)"]
            PDB_SEED["PDB#36;SEED <br> (Khuôn mẫu)"]
        end
        CDB --> PDB1
        CDB --> PDB2
        CDB --> PDB_SEED
    end
    %% Định nghĩa các class màu sắc
    classDef rootDB fill:#4CAF50,stroke:#2E7D32,stroke-width:3px,color:#FFFFFF
    classDef hrDB fill:#2196F3,stroke:#1565C0,stroke-width:2px,color:#FFFFFF
    classDef salesDB fill:#FF9800,stroke:#E65100,stroke-width:2px,color:#FFFFFF
    classDef seedDB fill:#9C27B0,stroke:#6A1B9A,stroke-width:2px,color:#FFFFFF
    %% Áp dụng màu cho các node
    class CDB rootDB
    class PDB1 hrDB
    class PDB2 salesDB
    class PDB_SEED seedDB
```

**Giải thích sơ đồ:**
- **Container Database (CDB):** Quản lý tài nguyên chung (metadata, users chung).
- **Pluggable Database (PDB):** Các cơ sở dữ liệu độc lập chứa dữ liệu ứng dụng, có thể "cắm" vào hoặc rút ra khỏi CDB một cách dễ dàng.
- **PDB_SEED:** Bản mẫu để tạo PDB mới nhanh chóng.

**Ví dụ thực tế:** Để tạo một PDB mới, sử dụng lệnh:
```sql
CREATE PLUGGABLE DATABASE PDB_NEW FROM PDB_SEED;
ALTER PLUGGABLE DATABASE PDB_NEW OPEN;
```
Quá trình này chỉ mất vài phút, thay vì cài đặt cơ sở dữ liệu mới từ đầu.

#### 1.3 Kết Hợp RAC Với Multitenant

Khi kết hợp Oracle RAC với kiến trúc Multitenant, chúng ta có được một hệ thống vừa có tính sẵn sàng cao, vừa tối ưu hóa tài nguyên hệ thống. Đây là giải pháp lý tưởng cho các doanh nghiệp cần quản lý nhiều ứng dụng khác nhau trên cùng một nền tảng cơ sở dữ liệu.

```mermaid
graph TD
    subgraph "Clients/Application"
        A[App Server 1]
        B[App Server 2]
    end
    subgraph "Oracle RAC Cluster"
        N1[Node 1: Oracle Instance]
        N2[Node 2: Oracle Instance]
    end
    SS[Shared Storage <br> ASM Disks]
    A --> N1
    B --> N2
    N1 <-->|Cluster Interconnect| N2
    N1 --> SS
    N2 --> SS
    subgraph "CDB#ROOT"
        PDB1["PDB_HR <br> (Nhân sự)"]
        PDB2["PDB_SALES <br> (Kinh doanh)"]
        PDB_SEED["PDB#SEED"]
    end
    N1 -->|Quản lý| CDB#ROOT
    N2 -->|Quản lý| CDB#ROOT
    CDB#ROOT --> PDB1
    CDB#ROOT --> PDB2
    CDB#ROOT --> PDB_SEED
    %% Styling
    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px,color:#000
    style B fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    style N1 fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    style N2 fill:#fce4ec,stroke:#c2185b,stroke-width:3px,color:#000
    style SS fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px,color:#000
    style CDB#ROOT fill:#4CAF50,stroke:#2E7D32,stroke-width:3px,color:#FFFFFF
    style PDB1 fill:#2196F3,stroke:#1565C0,stroke-width:2px,color:#FFFFFF
    style PDB2 fill:#FF9800,stroke:#E65100,stroke-width:2px,color:#FFFFFF
    style PDB_SEED fill:#9C27B0,stroke:#6A1B9A,stroke-width:2px,color:#FFFFFF
```

**Giải thích sơ đồ:**
- **CDB (Container Database)** chạy trên toàn bộ cụm RAC, mỗi node trong RAC đều có thể truy cập vào CDB.
- **PDB (Pluggable Database)** được chia sẻ giữa các node RAC. Một PDB có thể được mở trên tất cả các node hoặc chỉ trên một số node cụ thể, tùy theo cấu hình.
- **Phân bố tải (Load Balancing)**: Traffic đến các PDB được phân phối qua các node RAC, giúp cân bằng tải và tăng hiệu suất xử lý.
- **Tính sẵn sàng cao**: Nếu một node RAC gặp sự cố, các PDB sẽ tự động được phục hồi trên các node còn lại mà không làm gián đoạn dịch vụ.

**Lợi ích chính khi kết hợp RAC và Multitenant**

| Lợi ích | Mô tả |
|---------|-------|
| **Tối ưu tài nguyên** | Nhiều PDB chia sẻ tài nguyên của cụm RAC, giảm chi phí phần cứng và quản lý |
| **Khả năng mở rộng linh hoạt** | Dễ dàng mở rộng bằng cách thêm node RAC hoặc thêm PDB mới |
| **Phục hồi nhanh chóng** | Khi một node gặp sự cố, các PDB sẽ tự động được phục hồi trên các node còn lại |
| **Quản lý tập trung** | Quản lý nhiều PDB từ một điểm duy nhất trong khi vẫn đảm bảo tính độc lập |
| **Giảm thời gian bảo trì** | Có thể bảo trì từng node mà không ảnh hưởng đến toàn bộ hệ thống |

### 2. Vận Hành Cơ Bản Trong Môi Trường RAC

#### 2.1 Sự Khác Biệt Giữa Tài Khoản `oracle` và `grid`

Trong môi trường Oracle RAC, có hai tài khoản hệ thống quan trọng mà bất kỳ DBA nào cũng cần hiểu rõ:

```mermaid
flowchart TD
    subgraph "Tài khoản Grid (grid)"
        direction TB
        G1["Quản lý hạ tầng cụm"]
        G2["Clusterware (CRS)"]
        G3["ASM (Automatic Storage Management)"]
        G4["Oracle Net Listener"]
        G5["Các resource của cluster"]
    end
    
    subgraph "Tài khoản Oracle (oracle)"
        direction TB
        O1["Quản lý database"]
        O2["Instance database"]
        O3["SQL/PLSQL"]
        O4["Pluggable Databases (PDBs)"]
        O5["Backup/Restore (RMAN)"]
    end
    
    A["Ứng dụng"] -->|Kết nối| O4
    G5 -->|Kiểm soát| O2
    G3 -->|Quản lý| SS["Shared Storage"]
    
    style G1 fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    style O1 fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style G5 fill:#fff8e1,stroke:#f57f17,stroke-width:2px
    style O2 fill:#fce4ec,stroke:#c2185b,stroke-width:2px
    style SS fill:#e0f2f1,stroke:#00695c,stroke-width:2px
```

**🔑 Tài khoản `grid`**
- **Vai trò**: Sở hữu và quản lý **Oracle Grid Infrastructure** (phần hạ tầng cụm)
- **Quyền hạn**:
  - Quản lý Clusterware (CRS - Cluster Ready Services)
  - Quản lý Automatic Storage Management (ASM)
  - Quản lý Oracle Net Listener
  - Kiểm soát các resource của cluster (database, service, listener)
- **Không có quyền** truy cập vào dữ liệu trong database
- **Mục đích chính**: Đảm bảo hạ tầng cụm hoạt động ổn định, sẵn sàng cao

**🗄️ Tài khoản `oracle`**
- **Vai trò**: Sở hữu và quản lý **Oracle Database software**
- **Quyền hạn**:
  - Quản lý các instance database
  - Thực thi các lệnh SQL/PLSQL
  - Quản lý PDBs trong kiến trúc Multitenant
  - Thực hiện backup/restore (qua RMAN)
  - Quản lý schema, user, quyền hạn trong database
- **Không có quyền** quản lý các resource của cluster
- **Mục đích chính**: Đảm bảo database hoạt động và dữ liệu được quản lý đúng cách

#### 2.2 Các Câu Lệnh Vận Hành Chính và Tình Huống Sử Dụng

**✅ Câu lệnh 1: Kiểm tra trạng thái PDBs**

```
su - oracle
sqlplus / as sysdba
show pdbs  -- kiểm tra trạng thái các Pluggable Database (PDBs)
```

- **Tại sao dùng `oracle`?** Vì đây là thao tác trực tiếp trên database, yêu cầu quyền quản trị database
- **Mục đích**: Kiểm tra trạng thái open/read-write của các PDB
- **Tình huống sử dụng thực tế**:
  - Ứng dụng báo lỗi "ORA-01033: ORACLE initialization or shutdown in progress"
  - Kiểm tra routine hàng ngày để đảm bảo tất cả PDBs đang hoạt động
  - Sau khi khởi động lại hệ thống, xác minh xem các PDBs đã tự động mở chưa

**Kết quả mẫu:**
```
    CON_ID CON_NAME       OPEN MODE  RESTRICTED
---------- -------------- ---------- ----------
         2 PDB$SEED       READ ONLY  NO
         3 HR_PDB         READ WRITE NO   --> Bình thường
         4 SALES_PDB      MOUNTED         --> Cần xử lý
         5 FINANCE_PDB    READ WRITE YES  --> Đang ở chế độ restricted
```

- **Phân tích kết quả**:
  - Nếu PDB ở trạng thái `MOUNT`: Cần mở PDB (sử dụng Câu lệnh 4)
  - Nếu PDB ở trạng thái `READ ONLY`: Ứng dụng không thể ghi dữ liệu
  - Nếu PDB không hiển thị: Có thể chưa được cắm vào CDB
  - Nếu PDB ở trạng thái `RESTRICTED = YES`: Chỉ user có quyền RESTRICTED SESSION mới kết nối được

**Sơ đồ phân tích kết quả lệnh `show pdbs`:**
```mermaid
flowchart TD
    A[Thực hiện lệnh] --> B[/show pdbs/]
    B --> C{Phân tích kết quả}
    C -->|MOUNTED| D["Cần mở PDB (Câu lệnh 4)"]
    C -->|READ ONLY| E["Ứng dụng không thể ghi dữ liệu"]
    C -->|READ WRITE| F["PDB hoạt động bình thường"]
    C -->|Không hiển thị| G["PDB chưa được cắm vào CDB"]
    
    classDef normal fill:#D4EDD4,stroke:#28A745;
    classDef warning fill:#FFF3CD,stroke:#FFC107;
    classDef error fill:#F8D7DA,stroke:#DC3545;
    classDef critical fill:#D1ECF1,stroke:#0D6EFD;
    
    class D error;
    class E warning;
    class F normal;
    class G critical;
```

**✅ Câu lệnh 2: Kiểm tra trạng thái cluster**

```
su - grid
crsctl stat res -t   -- kiểm tra trạng thái các resource trong cluster
lsnrctl status       -- kiểm tra listener có đang hoạt động hay không
```

- **Tại sao dùng `grid`?** Vì đây là thao tác quản lý hạ tầng cụm, không liên quan trực tiếp đến dữ liệu
- **Mục đích**: Dùng khi câu lệnh 1 cho thấy PDB chưa ở trạng thái open
- **Tình huống sử dụng thực tế**:
  - Khi không thể kết nối đến database dù đã thử nhiều cách
  - Khi nghi ngờ một node trong RAC đã bị down
  - Khi thực hiện bảo trì cluster

**Kết quả mẫu `crsctl stat res -t` (trích một phần):**
```
--------------------------------------------------------------------------------
Name           Target  State        Server                   State details       
--------------------------------------------------------------------------------
Cluster Resources
--------------------------------------------------------------------------------
ora.LISTENER.lsnr
      1        ONLINE  ONLINE       node1                    STABLE
      2        ONLINE  ONLINE       node2                    STABLE
ora.PDBS.db
      1        ONLINE  ONLINE       node1                    Open,HOME=/u01/app/oracle/product/19.0.0/dbhome_1,STABLE
      2        ONLINE  ONLINE       node2                    Open,HOME=/u01/app/oracle/product/19.0.0/dbhome_1,STABLE
ora.SALES_PDB.pdb
      1        ONLINE  OFFLINE                               STABLE
ora.HR_PDB.pdb
      1        ONLINE  ONLINE       node1                    Open,STABLE
--------------------------------------------------------------------------------
```

**Kết quả mẫu `lsnrctl status` (trích một phần):**
```
Services Summary...
Service "+ASM" has 1 instance(s).
  Instance "+ASM1", status READY, has 1 handler(s) for this service...
Service "PDBS" has 2 instance(s).
  Instance "PDBS1", status READY, has 1 handler(s) for this service...
  Instance "PDBS2", status READY, has 1 handler(s) for this service...
Service "SALES_PDB" has 1 instance(s).
  Instance "PDBS1", status BLOCKED, has 1 handler(s) for this service...
The command completed successfully
```

- **Phân tích kết quả**:
  - Nếu resource database ở trạng thái `OFFLINE`: Cần khởi động database (Câu lệnh 3)
  - Nếu listener ở trạng thái `BLOCKED` hoặc không hiển thị: Cần khởi động lại listener
  - Nếu có resource ở trạng thái `UNKNOWN`: Có vấn đề nghiêm trọng với cluster

**Sơ đồ phân tích kết quả lệnh kiểm tra cluster:**
```mermaid
flowchart LR
    A[crsctl stat res -t] --> B{{STATE}}
    B -->|ONLINE| C[Tài nguyên hoạt động tốt]
    B -->|OFFLINE| D[Cần khởi động]
    B -->|UNKNOWN| E[Sự cố nghiêm trọng]
    
    F[lsnrctl status] --> G{{"Kết quả"}}
    G -->|"Listening... (PORT=1521)"| H[Lắng nghe kết nối]
    G -->|"No listener"| I[Cần khởi động listener]
    
    classDef normal fill:#D4EDD4,stroke:#28A745;
    classDef warning fill:#FFF3CD,stroke:#FFC107;
    classDef error fill:#F8D7DA,stroke:#DC3545;
    classDef critical fill:#D1ECF1,stroke:#0D6EFD;
    
    class C normal;
    class D error;
    class E critical;
    class H normal;
    class I error;
```

**✅ Câu lệnh 3: Khởi động database**

```
su - oracle
sqlplus / as sysdba
startup
```

- **Tại sao dùng `oracle`?** Vì đây là thao tác khởi động instance database
- **Mục đích**: Dùng để khởi động database
- **Tình huống sử dụng thực tế**:
  - Sau khi bảo trì phần cứng/mạng, cần khởi động lại database
  - Khi xác nhận từ câu lệnh 2 rằng cluster hoạt động nhưng database resource ở trạng thái OFFLINE
  - Khi database bị shutdown do lỗi hoặc bảo trì

**Kết quả mẫu:**
```
SQL> startup
ORACLE instance started.
Total System Global Area 2.51658240E+10 bytes
Fixed Size                  9151488 bytes
Variable Size            3221225472 bytes
Database Buffers         2.18103849E+10 bytes
Redo Buffers              124964864 bytes
Database mounted.
Database opened.
SQL> 
```

- **Lưu ý quan trọng**:
  - **Chỉ nên sử dụng sau khi kiểm tra bằng câu lệnh 1 và 2**, đảm bảo cluster hoạt động bình thường
  - **Không bao giờ** chạy lệnh này nếu câu lệnh 2 cho thấy cluster không ổn định
  - Nếu khởi động không thành công, cần kiểm tra file alert.log để xác định nguyên nhân

**Sơ đồ quy trình thực hiện lệnh STARTUP:**
```mermaid
flowchart TD
    A[Bắt đầu] --> B{Đã kiểm tra cluster?}
    B -->|No| C["Dừng lại! Kiểm tra câu lệnh 2 trước"]
    B -->|Yes| D{Cluster ổn định?}
    D -->|No| E["Xử lý sự cố cluster trước"]
    D -->|Yes| F[Thực hiện STARTUP]
    F --> G{Thành công?}
    G -->|Yes| H[Database hoạt động]
    G -->|No| I[Kiểm tra alert.log]
    
    classDef normal fill:#D4EDD4,stroke:#28A745;
    classDef warning fill:#FFF3CD,stroke:#FFC107;
    classDef error fill:#F8D7DA,stroke:#DC3545;
    classDef critical fill:#D1ECF1,stroke:#0D6EFD;
    
    class H normal;
    class C error;
    class E critical;
    class D warning;
    class G warning;
    class I error;
```

**✅ Câu lệnh 4: Mở PDB**

```
alter pluggable database <tên_pdb> open;
```

- **Tại sao dùng `oracle`?** Vì đây là thao tác quản trị database
- **Mục đích**: Dùng khi câu lệnh `show pdbs` cho thấy một PDB đang ở **mode: MOUNT**
- **Tình huống sử dụng thực tế**:
  - Sau khi khởi động CDB, các PDB không tự động mở (tùy cấu hình)
  - Khi PDB bị shutdown để bảo trì và cần mở lại
  - Khi PDB chuyển sang trạng thái MOUNT do lỗi

**Kết quả mẫu:**
```
SQL> alter pluggable database SALES_PDB open;
Pluggable database altered.
SQL> show pdbs
    CON_ID CON_NAME       OPEN MODE  RESTRICTED
---------- -------------- ---------- ----------
         2 PDB$SEED       READ ONLY  NO
         3 HR_PDB         READ WRITE NO
         4 SALES_PDB      READ WRITE NO   --> Đã mở thành công
         5 FINANCE_PDB    READ WRITE YES
```

- **Lưu ý quan trọng**:
  - Có thể mở tất cả PDB cùng lúc với lệnh: `alter pluggable database all open;`
  - Nếu PDB không mở được, cần kiểm tra với: `SELECT name, cause, message FROM v$pdbs_alert;`
  - Khi mở PDB, có thể chỉ định chế độ: `alter pluggable database SALES_PDB open read write;`

**Sơ đồ xử lý các trạng thái PDB:**
```mermaid
flowchart LR
    A[Trạng thái PDB] --> B{{MOUNTED}}
    A --> C{{READ ONLY}}
    A --> D{{READ WRITE}}
    
    B --> E["Thực hiện ALTER PLUGGABLE... OPEN"]
    C --> F["Thực hiện ALTER PLUGGABLE... OPEN READ WRITE"]
    D --> G["Không cần hành động"]
    
    classDef normal fill:#D4EDD4,stroke:#28A745;
    classDef warning fill:#FFF3CD,stroke:#FFC107;
    classDef error fill:#F8D7DA,stroke:#DC3545;
    
    class B error;
    class C warning;
    class D normal;
    class E error;
    class F warning;
    class G normal;
```

#### 2.3 Quy Trình Xử Lý Sự Cố Tiêu Chuẩn

Khi gặp vấn đề kết nối database, hãy tuân theo quy trình sau:

1. **Bước 1**: Sử dụng câu lệnh 1 để kiểm tra trạng thái PDBs
   - Nếu PDBs OPEN → Vấn đề ở ứng dụng hoặc network
   - Nếu PDBs không OPEN → Chuyển sang bước 2

2. **Bước 2**: Sử dụng câu lệnh 2 để kiểm tra trạng thái cluster
   - Nếu cluster hoạt động bình thường → Chuyển sang bước 3
   - Nếu cluster có vấn đề → Cần khắc phục sự cố cluster trước

3. **Bước 3**: Nếu database chưa được khởi động (OFFLINE) → Sử dụng câu lệnh 3

4. **Bước 4**: Sau khi database đã chạy → Sử dụng câu lệnh 4 để mở PDB

**Sơ đồ quy trình xử lý sự cố kết nối:**
```mermaid
flowchart TD
    S[Ứng dụng lỗi kết nối] --> A1["B1: show pdbs (oracle)"]
    A1 -- "KQ: SALES_PDB MOUNTED" --> A2["B2: crsctl stat res -t (grid)"]
    A2 -- "KQ: Cluster ONLINE" --> A3["B3: ALTER PLUGGABLE DATABASE SALES_PDB OPEN (oracle)"]
    A3 --> Z[Kết nối thành công]
    
    A1 -- "KQ: Tất cả OPEN" --> B1[Kiểm tra mạng/ứng dụng]
    A2 -- "KQ: Cluster OFFLINE" --> C1[Xử lý sự cố cluster]
    
    classDef normal fill:#D4EDD4,stroke:#28A745;
    classDef warning fill:#FFF3CD,stroke:#FFC107;
    classDef error fill:#F8D7DA,stroke:#DC3545;
    classDef critical fill:#D1ECF1,stroke:#0D6EFD;
    
    class Z normal;
    class B1 warning;
    class C1 error;
    class A3 normal;
```

**Ví Dụ Thực Tế**

**Tình huống**: Ứng dụng không kết nối được đến PDB_SALES

**Quy trình xử lý**:
1. Chạy câu lệnh 1:
   ```
   su - oracle
   sqlplus / as sysdba
   show pdbs
   ```
   → Kết quả:
   ```
       CON_ID CON_NAME       OPEN MODE  RESTRICTED
   ---------- -------------- ---------- ----------
            2 PDB$SEED       READ ONLY  NO
            3 HR_PDB         READ WRITE NO
            4 SALES_PDB      MOUNTED         --> Cần xử lý
   ```

2. Chạy câu lệnh 2:
   ```
   su - grid
   crsctl stat res -t
   ```
   → Kết quả: Tất cả resource ONLINE

3. Vì cluster hoạt động bình thường nhưng PDB_SALES chưa mở:
   ```
   su - oracle
   sqlplus / as sysdba
   alter pluggable database PDB_SALES open;
   ```
   → Kết quả:
   ```
   Pluggable database altered.
   ```

4. Kiểm tra lại bằng câu lệnh 1 để xác nhận PDB_SALES đã ở trạng thái OPEN:
   ```
   show pdbs
   ```
   → Kết quả:
   ```
       CON_ID CON_NAME       OPEN MODE  RESTRICTED
   ---------- -------------- ---------- ----------
            2 PDB$SEED       READ ONLY  NO
            3 HR_PDB         READ WRITE NO
            4 SALES_PDB      READ WRITE NO   --> Đã mở thành công
   ```

#### 2.4 Quy Trình Khởi Động (Startup) Một Cơ Sở Dữ Liệu RAC

```mermaid
flowchart TD
    A[Bắt đầu] --> B{Đăng nhập vào server};
    B --> C[su - grid <br/> <i>Chuyển sang user 'grid'</i>];
    C --> D[crsctl stat res -t <br/> <i>Kiểm tra trạng thái Clusterware</i>];
    D --> E{Cluster đã chạy chưa?};
    E --Chưa--> F[crsctl start cluster <br/> <i>Khởi động Clusterware</i>];
    E --Rồi--> G[su - oracle <br/> <i>Chuyển sang user 'oracle'</i>];
    F --> G;
    G --> H[sqlplus / as sysdba <br/> <i>Kết nối vào SQL*Plus</i>];
    H --> I[startup <br/> <i>Khởi động Database Instance</i>];
    I --> J{PDB đã mở chưa?};
    J --Chưa--> K[alter pluggable database <br/> TÊN_PDB open;];
    K --> L[Kết thúc];
    J --Rồi--> L;
    %% Định nghĩa các class màu sắc
    classDef startEnd fill:#e1f5fe,stroke:#01579b,stroke-width:3px,color:#000
    classDef decision fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#000
    classDef gridUser fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    classDef oracleUser fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000
    classDef clusterOps fill:#fff8e1,stroke:#f57f17,stroke-width:2px,color:#000
    classDef dbOps fill:#fce4ec,stroke:#c2185b,stroke-width:2px,color:#000
    classDef pdbOps fill:#e0f2f1,stroke:#00695c,stroke-width:2px,color:#000
    %% Áp dụng màu sắc
    class A,L startEnd
    class B,E,J decision
    class C,D gridUser
    class G,H oracleUser
    class F clusterOps
    class I dbOps
    class K pdbOps
```

**Lệnh thực tế:**

| Bước | Lệnh | Mô tả |
|------|------|-------|
| Kiểm tra trạng thái cluster | `crsctl stat res -t` | Xem tất cả resource có đang ONLINE không |
| Khởi động cluster | `crsctl start cluster -all` | Chỉ dùng khi cluster chưa chạy |
| Đăng nhập vào DB | `sqlplus / as sysdba` | Kết nối với quyền cao nhất |
| Xem trạng thái PDB | `show pdbs` | Kiểm tra PDB nào chưa mở |
| Mở tất cả PDB | `alter pluggable database all open` | Bắt buộc sau khi khởi động CDB |

**Xử Lý Lỗi Thường Gặp:**
- **Không khởi động được Clusterware:** Sử dụng `crsctl check cluster -all`. Nếu lỗi CRS-4535, chạy `crsctl start cluster -all`.
- **PDB không mở được:** Kiểm tra với `SELECT name, open_mode, total_size/1024/1024 "Size (MB)" FROM v$pdbs;`. Mở lực lượng nếu cần: `ALTER PLUGGABLE DATABASE PDB_HR OPEN FORCE;`.
- **Diskgroup ASM đầy:** Kiểm tra `SELECT name, total_mb, free_mb, (free_mb/total_mb)*100 "FREE%" FROM v$asm_diskgroup;`. Thêm đĩa: `ALTER DISKGROUP DATA ADD DISK '/dev/sdx1';`.

### 3. Giám Sát Và Chẩn Đoán Hiệu Năng

**Quy Trình Chẩn Đoán Một Vấn Đề Về Hiệu Năng**

Luôn kiểm tra theo thứ tự: OS → Storage → Database để tiết kiệm thời gian.

```mermaid
flowchart TD
    Start[Phát hiện hệ thống chậm] --> L1{"Lớp 1: Kiểm tra OS"};
    L1 --"OK"--> L2{"Lớp 2: Kiểm tra Storage (ASM)"};
    L1 --"Co van de"--> FixOS["Xử lý vấn đề OS <br/> (CPU/RAM cao, I/O wait)"];
    L2 --"OK"--> L3{"Lớp 3: Kiểm tra Database"};
    L2 --"Co van de"--> FixASM["Xử lý vấn đề Storage <br/> (Disk group đầy, lỗi disk)"];
    L3 --> S1["<b>Bước 1:</b> Tìm session 'ACTIVE' <br/> <i>(dùng gv$session)</i>"];
    S1 --> S2["Lấy ra <b>sql_id</b> và <b>last_call_et</b>"];
    S2 --> S3["<b>Bước 2:</b> Tìm nội dung câu lệnh <br/> <i>(dùng gv$sqlarea với sql_id)</i>"];
    S3 --> End["Tối ưu câu lệnh SQL <br/> (Thêm index, viết lại logic...)"]
    subgraph OSCommands ["Các lệnh kiểm tra OS"]
        direction LR
        top[top]
        free[free -g]
        iostat[iostat]
    end
    L1 --> OSCommands
    subgraph DBCommands ["Các lệnh kiểm tra DB"]
        direction LR
        q1[select ... from gv$session]
        q2[select ... from gv$sqlarea]
    end
    L3 --> DBCommands
    %% Định nghĩa các class màu sắc
    classDef startNode fill:#e1f5fe,stroke:#01579b,stroke-width:3px,color:#000
    classDef checkNode fill:#f3e5f5,stroke:#4a148c,stroke-width:2px,color:#000
    classDef fixNode fill:#ffebee,stroke:#b71c1c,stroke-width:2px,color:#000
    classDef processNode fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    classDef endNode fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    classDef commandNode fill:#f1f8e9,stroke:#33691e,stroke-width:1px,color:#000
    classDef subgraphStyle fill:#fafafa,stroke:#757575,stroke-width:2px
    %% Áp dụng class cho các node
    class Start startNode
    class L1,L2,L3 checkNode
    class FixOS,FixASM fixNode
    class S1,S2,S3 processNode
    class End endNode
    class top,free,iostat,q1,q2 commandNode
```

**Công Cụ Kiểm Tra Nhanh:**

| Lớp | Công cụ | Chỉ số cần quan tâm | Mức nguy hiểm |
|-----|---------|---------------------|---------------|
| OS | `top` | %CPU, %MEM, load average | >80% liên tục |
| OS | `free -g` | available memory | <10% total |
| Storage | `iostat 2 5` | %util, await | %util >90% |
| ASM | `v$asm_diskgroup` | free_mb/total_mb | <10% free |
| DB | `gv$session` | last_call_et, status | >300s |

**Các Câu Lệnh SQL Chẩn Đoán:**

1. **Tìm session đang chạy lâu và lấy `sql_id`:**
   ```sql
   SELECT sid, serial#, username, machine,
          sql_id, last_call_et/60 "Phút"
   FROM gv$session
   WHERE status = 'ACTIVE'
     AND type != 'BACKGROUND'
     AND last_call_et > 300
   ORDER BY last_call_et DESC;
   ```

2. **Lấy nội dung câu lệnh SQL từ `sql_id`:**
   ```sql
   SELECT sql_fulltext
   FROM gv$sqlarea
   WHERE sql_id = ':your_sql_id';
   ```

## Phần II: MongoDB

### 1. Kiến Trúc Sharding (Phân Mảnh)

Sharding phân tán dữ liệu ra nhiều máy chủ để xử lý khối lượng lớn, cải thiện tốc độ và độ sẵn sàng.

```mermaid
graph TD
    App["Ứng dụng"] --> Mongos["Mongos Router"];
    subgraph "Metadata"
        Config["Config Servers<br/>(Lưu cấu hình Sharding)"]
    end
    subgraph "Data Storage"
        Shard1["Shard 1<br/>(Replica Set)"]
        Shard2["Shard 2<br/>(Replica Set)"]
        Shard3["Shard 3<br/>(Replica Set)"]
    end
    Mongos -- "Truy vấn & ghi dữ liệu" --> Shard1;
    Mongos -- "Truy vấn & ghi dữ liệu" --> Shard2;
    Mongos -- "Truy vấn & ghi dữ liệu" --> Shard3;
    Mongos -- "Đọc metadata" --> Config;
    %% Styling với nhiều màu sắc
    style App fill:#FF6B6B,stroke:#FF4757,stroke-width:3px,color:#fff
    style Mongos fill:#4ECDC4,stroke:#26D0CE,stroke-width:3px,color:#fff
    style Config fill:#FFE66D,stroke:#FFD93D,stroke-width:3px,color:#333
    style Shard1 fill:#A8E6CF,stroke:#7FCDCD,stroke-width:2px,color:#333
    style Shard2 fill:#88D8C0,stroke:#52C7B8,stroke-width:2px,color:#333
    style Shard3 fill:#6FCF97,stroke:#27AE60,stroke-width:2px,color:#333
    %% Styling cho subgraph
    classDef metadataGroup fill:#FFF5B4,stroke:#F39C12,stroke-width:2px
    classDef storageGroup fill:#E8F8F5,stroke:#16A085,stroke-width:2px
```

**Giải thích sơ đồ:**
- **Ứng dụng:** Kết nối qua Mongos.
- **Mongos (Router):** Định tuyến truy vấn dựa trên metadata từ Config Servers.
- **Config Servers:** Lưu bản đồ dữ liệu (ít nhất 3 server cho production).
- **Shards:** Các replica set lưu trữ dữ liệu phân mảnh.

**Replica Set Trong Shard:** Mỗi shard là một replica set với primary (xử lý write) và secondary (sao chép dữ liệu, hỗ trợ read). Cơ chế failover tự động khi primary thất bại.

### 2. Vận Hành Và Giám Sát

#### 1. Quy Trình Import Dữ Liệu Vào Sharded Cluster

```mermaid
flowchart TD
    Client["Client/Tool (mongoimport, Studio 3T...)"]
    subgraph "ĐÚNG"
        direction LR
        R1[Client] --> R2[Mongos] --> R3["Các Shard (Mongos tự điều phối)"]
    end
    subgraph "SAI"
        direction LR
        W1[Client] --> W2["Kết nối trực tiếp vào Shard 1"]
    end
    Client -- Nên làm --> R1
    Client -- Không nên làm --> W1
    style R2 fill:#9f9
    style W2 fill:#f66
```

**Lưu ý quan trọng:** Luôn import qua Mongos để tránh mất cân bằng dữ liệu. Ví dụ lệnh đúng:
```bash
mongoimport --host mongos-host:27017 --db mydb --collection users --file data.json --numInsertionWorkers 8
```

#### 2. Giám Sát Với MongoDB Compass

Kết nối Compass đến Mongos, vào tab Performance để xem Slowest Operations.

**Kết quả mẫu khi kiểm tra trạng thái cluster:**
```
--- Sharding Status --- 
  sharding version: {
    "_id" : 1,
    "minCompatibleVersion" : 5,
    "currentVersion" : 6,
    "clusterId" : ObjectId("64a0b3d8e1b1d0b0c8e1b1d0")
  }
  shards:
    {  "_id" : "shard01",  "host" : "shard01/mongo-shard01-01:27018,mongo-shard01-02:27018,mongo-shard01-03:27018",  "state" : 1 }
    {  "_id" : "shard02",  "host" : "shard02/mongo-shard02-01:27018,mongo-shard02-02:27018,mongo-shard02-03:27018",  "state" : 1 }
    {  "_id" : "shard03",  "host" : "shard03/mongo-shard03-01:27018,mongo-shard03-02:27018,mongo-shard03-03:27018",  "state" : 1 }
  active mongoses:
    "4.4.22" : 3
  autosplit:
    Currently enabled: yes
  balancer:
    Currently enabled:  yes
    Currently running:  no
    Failed balancer rounds in last 5 attempts:  0
    Migration Results for the last 24 hours: 
        No recent migrations
  databases:
    {  "_id" : "config",  "primary" : "config",  "partitioned" : true }
    {  "_id" : "mydb",  "primary" : "shard01",  "partitioned" : true }
        mydb.users
            shard key: { "user_id" : 1 }
            unique: false
            balancing: true
            chunks:
                shard01    45
                shard02    43
                shard03    42
            too many chunks
```

**Chỉ Số Cần Quan Tâm:**

| Chỉ số | Ý nghĩa | Mức cảnh báo |
|--------|---------|--------------|
| Execution Time | Thời gian chạy truy vấn | >500ms |
| Docs Examined | Số document quét | Cao hơn nReturned nhiều lần |
| nReturned | Số document trả về | - |
| Index Used | Có dùng index không | Nên luôn là YES |
| Shard Targeting | Số shard được truy vấn | Càng ít càng tốt |

**Cách tối ưu:** Tạo index (`db.users.createIndex({email: 1})`) và sử dụng projection.

## Phần III: Tổng kết

### Checklist Hàng Ngày

**Oracle:**
- Kiểm tra trạng thái RAC: `crsctl stat res -t`
- Xem free space ASM: `SELECT name, free_mb FROM v$asm_diskgroup`
- Tìm session chạy lâu: `SELECT * FROM gv$session WHERE last_call_et > 300`
- Kiểm tra backup: `RMAN> LIST BACKUP SUMMARY;`

**MongoDB:**
- Trạng thái cluster: `sh.status()`
- Truy vấn chậm: `db.currentOp({"secs_running": {$gt: 5}})`
- Giám sát storage: `db.getSiblingDB('admin').runCommand({getShardMap: 1})`
- Replica set: `rs.status()`

### Công Cụ Hỗ Trợ

| Công cụ | Oracle | MongoDB | Mô tả |
|---------|--------|---------|-------|
| GUI | Toad | MongoDB Compass | Dễ dùng cho người mới |
| Giám sát | OEM | MongoDB Atlas | Theo dõi hiệu năng |
| Thực hành | Oracle Live SQL | MongoDB University | Học miễn phí |
| Backup | RMAN | mongodump | Backup tiêu chuẩn |