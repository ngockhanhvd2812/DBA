- [Hướng Dẫn Vận Hành Và Giám Sát Oracle \& MongoDB](#hướng-dẫn-vận-hành-và-giám-sát-oracle--mongodb)
  - [Phần I: Oracle Database](#phần-i-oracle-database)
    - [1. Kiến Trúc Cốt Lõi](#1-kiến-trúc-cốt-lõi)
    - [2. Vận Hành Cơ Bản Trong Môi Trường RAC](#2-vận-hành-cơ-bản-trong-môi-trường-rac)
    - [3. Giám Sát Và Chẩn Đoán Hiệu Năng](#3-giám-sát-và-chẩn-đoán-hiệu-năng)
  - [Phần II: MongoDB](#phần-ii-mongodb)
    - [1. Kiến Trúc Sharding (Phân Mảnh)](#1-kiến-trúc-sharding-phân-mảnh)
    - [2. Vận Hành Và Giám Sát](#2-vận-hành-và-giám-sát)
      - [1. Quy Trình Import Dữ Liệu Vào Sharded Cluster](#1-quy-trình-import-dữ-liệu-vào-sharded-cluster)
      - [2. Giám Sát Với MongoDB Compass](#2-giám-sát-với-mongodb-compass)
  - [Phần III: Tổng kết](#phần-iii-tổng-kết)
    - [Checklist Hàng Ngày](#checklist-hàng-ngày)
    - [Công Cụ Hỗ Trợ](#công-cụ-hỗ-trợ)


# Hướng Dẫn Vận Hành Và Giám Sát Oracle & MongoDB

## Phần I: Oracle Database

### 1. Kiến Trúc Cốt Lõi

**1.1 Oracle Real Application Clusters (RAC)**

Oracle RAC cho phép nhiều máy chủ (nodes) cùng truy cập vào một cơ sở dữ liệu duy nhất, mang lại tính sẵn sàng cao và khả năng mở rộng. Điều này đặc biệt hữu ích khi hệ thống cần hoạt động liên tục 24/7, giảm thiểu thời gian ngừng hoạt động (downtime) khi một node gặp sự cố, tăng khả năng xử lý song song và dễ dàng mở rộng quy mô.

```mermaid
graph TD
    subgraph "Clients/Application"
        A[App Server 1]
        B[App Server 2]
    end
    subgraph "Oracle RAC Cluster"
        N1[Node 1: Oracle Instance]
        N2[Node 2: Oracle Instance]
    end
    SS[Shared Storage <br> ASM Disks]
    A --> N1
    B --> N2
    N1 <-->|Cluster Interconnect| N2
    N1 --> SS
    N2 --> SS
    %% Styling
    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px,color:#000
    style B fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    style N1 fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    style N2 fill:#fce4ec,stroke:#c2185b,stroke-width:3px,color:#000
    style SS fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px,color:#000
```

**Giải thích sơ đồ:**
- **Node 1 & Node 2:** Mỗi node là một máy chủ vật lý hoặc ảo chạy một instance Oracle, xử lý các yêu cầu từ ứng dụng.
- **Cluster Interconnect:** Mạng riêng tốc độ cao để các node trao đổi thông tin (cache fusion, heartbeat). Nếu kết nối này chậm hoặc không ổn định, hiệu năng RAC có thể kém hơn so với một instance đơn lẻ.
- **Shared Storage:** Nơi lưu trữ dữ liệu chung, thường sử dụng Automatic Storage Management (ASM) để quản lý hiệu quả.

**Lưu ý quan trọng:** Đảm bảo Cluster Interconnect có độ trễ thấp để tránh ảnh hưởng đến hiệu suất tổng thể.

**1.2 Kiến Trúc Multitenant (CDB & PDB)**

Kiến trúc này cho phép quản lý nhiều cơ sở dữ liệu độc lập trong một container chung, tiết kiệm tài nguyên hệ thống (CPU, RAM, storage), hỗ trợ triển khai nhanh chóng và tách biệt dữ liệu giữa các ứng dụng.

```mermaid
graph TD
    subgraph "Server"
        CDB["Container Database (CDB#36;ROOT)"]
        subgraph "Pluggable Databases (PDBs)"
            PDB1["PDB_HR <br> (Chứa dữ liệu Nhân sự)"]
            PDB2["PDB_SALES <br> (Chứa dữ liệu Kinh doanh)"]
            PDB_SEED["PDB#36;SEED <br> (Khuôn mẫu)"]
        end
        CDB --> PDB1
        CDB --> PDB2
        CDB --> PDB_SEED
    end
    %% Định nghĩa các class màu sắc
    classDef rootDB fill:#4CAF50,stroke:#2E7D32,stroke-width:3px,color:#FFFFFF
    classDef hrDB fill:#2196F3,stroke:#1565C0,stroke-width:2px,color:#FFFFFF
    classDef salesDB fill:#FF9800,stroke:#E65100,stroke-width:2px,color:#FFFFFF
    classDef seedDB fill:#9C27B0,stroke:#6A1B9A,stroke-width:2px,color:#FFFFFF
   
    %% Áp dụng màu cho các node
    class CDB rootDB
    class PDB1 hrDB
    class PDB2 salesDB
    class PDB_SEED seedDB
```

**Giải thích sơ đồ:**
- **Container Database (CDB):** Quản lý tài nguyên chung (metadata, users chung).
- **Pluggable Database (PDB):** Các cơ sở dữ liệu độc lập chứa dữ liệu ứng dụng, có thể "cắm" vào hoặc rút ra khỏi CDB một cách dễ dàng.
- **PDB_SEED:** Bản mẫu để tạo PDB mới nhanh chóng.

**Ví dụ thực tế:** Để tạo một PDB mới, sử dụng lệnh:
```sql
CREATE PLUGGABLE DATABASE PDB_NEW FROM PDB_SEED;
ALTER PLUGGABLE DATABASE PDB_NEW OPEN;
```
Quá trình này chỉ mất vài phút, thay vì cài đặt cơ sở dữ liệu mới từ đầu.

### 2. Vận Hành Cơ Bản Trong Môi Trường RAC

**Quy Trình Khởi Động (Startup) Một Cơ Sở Dữ Liệu RAC**

```mermaid
flowchart TD
    A[Bắt đầu] --> B{Đăng nhập vào server};
    B --> C[su - grid <br/> <i>Chuyển sang user 'grid'</i>];
    C --> D[crsctl stat res -t <br/> <i>Kiểm tra trạng thái Clusterware</i>];
    D --> E{Cluster đã chạy chưa?};
    E --Chưa--> F[crsctl start cluster <br/> <i>Khởi động Clusterware</i>];
    E --Rồi--> G[su - oracle <br/> <i>Chuyển sang user 'oracle'</i>];
    F --> G;
    G --> H[sqlplus / as sysdba <br/> <i>Kết nối vào SQL*Plus</i>];
    H --> I[startup <br/> <i>Khởi động Database Instance</i>];
    I --> J{PDB đã mở chưa?};
    J --Chưa--> K[alter pluggable database <br/> TÊN_PDB open;];
    K --> L[Kết thúc];
    J --Rồi--> L;
    %% Định nghĩa các class màu sắc
    classDef startEnd fill:#e1f5fe,stroke:#01579b,stroke-width:3px,color:#000
    classDef decision fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#000
    classDef gridUser fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    classDef oracleUser fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000
    classDef clusterOps fill:#fff8e1,stroke:#f57f17,stroke-width:2px,color:#000
    classDef dbOps fill:#fce4ec,stroke:#c2185b,stroke-width:2px,color:#000
    classDef pdbOps fill:#e0f2f1,stroke:#00695c,stroke-width:2px,color:#000
    %% Áp dụng màu sắc
    class A,L startEnd
    class B,E,J decision
    class C,D gridUser
    class G,H oracleUser
    class F clusterOps
    class I dbOps
    class K pdbOps
```

**Lệnh thực tế:**

| Bước | Lệnh | Mô tả |
|------|------|-------|
| Kiểm tra trạng thái cluster | `crsctl stat res -t` | Xem tất cả resource có đang ONLINE không |
| Khởi động cluster | `crsctl start cluster -all` | Chỉ dùng khi cluster chưa chạy |
| Đăng nhập vào DB | `sqlplus / as sysdba` | Kết nối với quyền cao nhất |
| Xem trạng thái PDB | `show pdbs` | Kiểm tra PDB nào chưa mở |
| Mở tất cả PDB | `alter pluggable database all open` | Bắt buộc sau khi khởi động CDB |

**Xử Lý Lỗi Thường Gặp:**

- **Không khởi động được Clusterware:** Sử dụng `crsctl check cluster -all`. Nếu lỗi CRS-4535, chạy `crsctl start cluster -all`.
- **PDB không mở được:** Kiểm tra với `SELECT name, open_mode, total_size/1024/1024 "Size (MB)" FROM v$pdbs;`. Mở lực lượng nếu cần: `ALTER PLUGGABLE DATABASE PDB_HR OPEN FORCE;`.
- **Diskgroup ASM đầy:** Kiểm tra `SELECT name, total_mb, free_mb, (free_mb/total_mb)*100 "FREE%" FROM v$asm_diskgroup;`. Thêm đĩa: `ALTER DISKGROUP DATA ADD DISK '/dev/sdx1';`.

### 3. Giám Sát Và Chẩn Đoán Hiệu Năng

**Quy Trình Chẩn Đoán Một Vấn Đề Về Hiệu Năng**

Luôn kiểm tra theo thứ tự: OS → Storage → Database để tiết kiệm thời gian.

```mermaid
flowchart TD
    Start[Phát hiện hệ thống chậm] --> L1{"Lớp 1: Kiểm tra OS"};
    L1 --"OK"--> L2{"Lớp 2: Kiểm tra Storage (ASM)"};
    L1 --"Co van de"--> FixOS["Xử lý vấn đề OS <br/> (CPU/RAM cao, I/O wait)"];
    L2 --"OK"--> L3{"Lớp 3: Kiểm tra Database"};
    L2 --"Co van de"--> FixASM["Xử lý vấn đề Storage <br/> (Disk group đầy, lỗi disk)"];
    L3 --> S1["<b>Bước 1:</b> Tìm session 'ACTIVE' <br/> <i>(dùng gv$session)</i>"];
    S1 --> S2["Lấy ra <b>sql_id</b> và <b>last_call_et</b>"];
    S2 --> S3["<b>Bước 2:</b> Tìm nội dung câu lệnh <br/> <i>(dùng gv$sqlarea với sql_id)</i>"];
    S3 --> End["Tối ưu câu lệnh SQL <br/> (Thêm index, viết lại logic...)"]
    subgraph OSCommands ["Các lệnh kiểm tra OS"]
        direction LR
        top[top]
        free[free -g]
        iostat[iostat]
    end
    L1 --> OSCommands
    subgraph DBCommands ["Các lệnh kiểm tra DB"]
        direction LR
        q1[select ... from gv$session]
        q2[select ... from gv$sqlarea]
    end
    L3 --> DBCommands
    %% Định nghĩa các class màu sắc
    classDef startNode fill:#e1f5fe,stroke:#01579b,stroke-width:3px,color:#000
    classDef checkNode fill:#f3e5f5,stroke:#4a148c,stroke-width:2px,color:#000
    classDef fixNode fill:#ffebee,stroke:#b71c1c,stroke-width:2px,color:#000
    classDef processNode fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    classDef endNode fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    classDef commandNode fill:#f1f8e9,stroke:#33691e,stroke-width:1px,color:#000
    classDef subgraphStyle fill:#fafafa,stroke:#757575,stroke-width:2px
    %% Áp dụng class cho các node
    class Start startNode
    class L1,L2,L3 checkNode
    class FixOS,FixASM fixNode
    class S1,S2,S3 processNode
    class End endNode
    class top,free,iostat,q1,q2 commandNode
```

**Công Cụ Kiểm Tra Nhanh:**

| Lớp | Công cụ | Chỉ số cần quan tâm | Mức nguy hiểm |
|-----|---------|---------------------|---------------|
| OS | `top` | %CPU, %MEM, load average | >80% liên tục |
| OS | `free -g` | available memory | <10% total |
| Storage | `iostat 2 5` | %util, await | %util >90% |
| ASM | `v$asm_diskgroup` | free_mb/total_mb | <10% free |
| DB | `gv$session` | last_call_et, status | >300s |

**Các Câu Lệnh SQL Chẩn Đoán:**

1. **Tìm session đang chạy lâu và lấy `sql_id`:**
   ```sql
   SELECT sid, serial#, username, machine,
          sql_id, last_call_et/60 "Phút"
   FROM gv$session
   WHERE status = 'ACTIVE'
     AND type != 'BACKGROUND'
     AND last_call_et > 300
   ORDER BY last_call_et DESC;
   ```

2. **Lấy nội dung câu lệnh SQL từ `sql_id`:**
   ```sql
   SELECT sql_fulltext
   FROM gv$sqlarea
   WHERE sql_id = ':your_sql_id';
   ```

## Phần II: MongoDB

### 1. Kiến Trúc Sharding (Phân Mảnh)

Sharding phân tán dữ liệu ra nhiều máy chủ để xử lý khối lượng lớn, cải thiện tốc độ và độ sẵn sàng.

```mermaid
graph TD
    App["Ứng dụng"] --> Mongos["Mongos Router"];
    subgraph "Metadata"
        Config["Config Servers<br/>(Lưu cấu hình Sharding)"]
    end
    subgraph "Data Storage"
        Shard1["Shard 1<br/>(Replica Set)"]
        Shard2["Shard 2<br/>(Replica Set)"]
        Shard3["Shard 3<br/>(Replica Set)"]
    end
    Mongos -- "Truy vấn & ghi dữ liệu" --> Shard1;
    Mongos -- "Truy vấn & ghi dữ liệu" --> Shard2;
    Mongos -- "Truy vấn & ghi dữ liệu" --> Shard3;
    Mongos -- "Đọc metadata" --> Config;
    %% Styling với nhiều màu sắc
    style App fill:#FF6B6B,stroke:#FF4757,stroke-width:3px,color:#fff
    style Mongos fill:#4ECDC4,stroke:#26D0CE,stroke-width:3px,color:#fff
    style Config fill:#FFE66D,stroke:#FFD93D,stroke-width:3px,color:#333
    style Shard1 fill:#A8E6CF,stroke:#7FCDCD,stroke-width:2px,color:#333
    style Shard2 fill:#88D8C0,stroke:#52C7B8,stroke-width:2px,color:#333
    style Shard3 fill:#6FCF97,stroke:#27AE60,stroke-width:2px,color:#333
    %% Styling cho subgraph
    classDef metadataGroup fill:#FFF5B4,stroke:#F39C12,stroke-width:2px
    classDef storageGroup fill:#E8F8F5,stroke:#16A085,stroke-width:2px
```

**Giải thích sơ đồ:**
- **Ứng dụng:** Kết nối qua Mongos.
- **Mongos (Router):** Định tuyến truy vấn dựa trên metadata từ Config Servers.
- **Config Servers:** Lưu bản đồ dữ liệu (ít nhất 3 server cho production).
- **Shards:** Các replica set lưu trữ dữ liệu phân mảnh.

**Replica Set Trong Shard:** Mỗi shard là một replica set với primary (xử lý write) và secondary (sao chép dữ liệu, hỗ trợ read). Cơ chế failover tự động khi primary thất bại.

### 2. Vận Hành Và Giám Sát

#### 1. Quy Trình Import Dữ Liệu Vào Sharded Cluster

```mermaid
flowchart TD
    Client["Client/Tool (mongoimport, Studio 3T...)"]
   
    subgraph "ĐÚNG"
        direction LR
        R1[Client] --> R2[Mongos] --> R3["Các Shard (Mongos tự điều phối)"]
    end
    subgraph "SAI"
        direction LR
        W1[Client] --> W2["Kết nối trực tiếp vào Shard 1"]
    end
    Client -- Nên làm --> R1
    Client -- Không nên làm --> W1
    style R2 fill:#9f9
    style W2 fill:#f66
```

**Lưu ý quan trọng:** Luôn import qua Mongos để tránh mất cân bằng dữ liệu. Ví dụ lệnh đúng:
```bash
mongoimport --host mongos-host:27017 --db mydb --collection users --file data.json --numInsertionWorkers 8
```

#### 2. Giám Sát Với MongoDB Compass

Kết nối Compass đến Mongos, vào tab Performance để xem Slowest Operations.

**Chỉ Số Cần Quan Tâm:**

| Chỉ số | Ý nghĩa | Mức cảnh báo |
|--------|---------|--------------|
| Execution Time | Thời gian chạy truy vấn | >500ms |
| Docs Examined | Số document quét | Cao hơn nReturned nhiều lần |
| nReturned | Số document trả về | - |
| Index Used | Có dùng index không | Nên luôn là YES |
| Shard Targeting | Số shard được truy vấn | Càng ít càng tốt |

**Cách tối ưu:** Tạo index (`db.users.createIndex({email: 1})`) và sử dụng projection.

## Phần III: Tổng kết

### Checklist Hàng Ngày

**Oracle:**
- Kiểm tra trạng thái RAC: `crsctl stat res -t`
- Xem free space ASM: `SELECT name, free_mb FROM v$asm_diskgroup`
- Tìm session chạy lâu: `SELECT * FROM gv$session WHERE last_call_et > 300`
- Kiểm tra backup: `RMAN> LIST BACKUP SUMMARY;`

**MongoDB:**
- Trạng thái cluster: `sh.status()`
- Truy vấn chậm: `db.currentOp({"secs_running": {$gt: 5}})`
- Giám sát storage: `db.getSiblingDB('admin').runCommand({getShardMap: 1})`
- Replica set: `rs.status()`

### Công Cụ Hỗ Trợ

| Công cụ | Oracle | MongoDB | Mô tả |
|---------|--------|---------|-------|
| GUI | Toad | MongoDB Compass | Dễ dùng cho người mới |
| Giám sát | OEM | MongoDB Atlas | Theo dõi hiệu năng |
| Thực hành | Oracle Live SQL | MongoDB University | Học miễn phí |
| Backup | RMAN | mongodump | Backup tiêu chuẩn |
