- [**Hướng dẫn Vận hành và Giám sát Oracle \& MongoDB**](#hướng-dẫn-vận-hành-và-giám-sát-oracle--mongodb)
  - [**Phần I: Oracle Database**](#phần-i-oracle-database)
    - [**1. Kiến trúc cốt lõi**](#1-kiến-trúc-cốt-lõi)
    - [**2. Vận hành Cơ bản trong Môi trường RAC**](#2-vận-hành-cơ-bản-trong-môi-trường-rac)
    - [**3. Giám sát và Chẩn đoán Hiệu năng**](#3-giám-sát-và-chẩn-đoán-hiệu-năng)
  - [**Phần II: MongoDB**](#phần-ii-mongodb)
    - [**1. Kiến trúc Sharding (Phân mảnh)**](#1-kiến-trúc-sharding-phân-mảnh)
    - [**2. Vận hành và Giám sát**](#2-vận-hành-và-giám-sát)
      - [**1. Quy trình Import dữ liệu vào Sharded Cluster**](#1-quy-trình-import-dữ-liệu-vào-sharded-cluster)
      - [**2. Giám sát với MongoDB Compass**](#2-giám-sát-với-mongodb-compass)


# **Hướng dẫn Vận hành và Giám sát Oracle & MongoDB**

## **Phần I: Oracle Database**

### **1. Kiến trúc cốt lõi**

**1. Oracle Real Application Clusters (RAC)**

RAC cho phép nhiều máy chủ (nodes) cùng truy cập vào một CSDL duy nhất, mang lại tính sẵn sàng cao và khả năng mở rộng tuyệt vời.

```mermaid
%%{init: {"flowchart": {"htmlLabels": true}} }%%
graph TD
    subgraph "Clients/Application"
        A[App Server 1]
        B[App Server 2]
    end

    subgraph "Oracle RAC Cluster"
        N1[Node 1: Oracle Instance]
        N2[Node 2: Oracle Instance]
    end

    SS[Shared Storage <br> ASM Disks]

    A --> N1
    B --> N2
    N1 <-->|Cluster Interconnect| N2
    N1 --> SS
    N2 --> SS

    %% Styling
    style A fill:#e1f5fe,stroke:#01579b,stroke-width:2px,color:#000
    style B fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    style N1 fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    style N2 fill:#fce4ec,stroke:#c2185b,stroke-width:3px,color:#000
    style SS fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px,color:#000
```

*   **Giải thích sơ đồ:**
    *   **Node 1 & Node 2:** Là hai máy chủ vật lý hoặc ảo, mỗi máy chạy một *instance* của Oracle.
    *   **Cluster Interconnect:** Là một mạng riêng tốc độ cao để các node trao đổi thông tin với nhau (cache fusion, heartbeat...).
    *   **Shared Storage:** Là nơi lưu trữ toàn bộ dữ liệu của CSDL, được cả hai node cùng truy cập.

**2. Kiến trúc Đa người dùng (Multitenant: CDB & PDB)**

Kiến trúc này giống như một tòa nhà chung cư: CDB là tòa nhà, còn các PDB là những căn hộ riêng biệt bên trong.

```mermaid
graph TD
    subgraph "Server"
        CDB["Container Database (CDB#36;ROOT)"]
        subgraph "Pluggable Databases (PDBs)"
            PDB1["PDB_HR <br> (Chứa dữ liệu Nhân sự)"]
            PDB2["PDB_SALES <br> (Chứa dữ liệu Kinh doanh)"]
            PDB_SEED["PDB#36;SEED <br> (Khuôn mẫu)"]
        end
        CDB --> PDB1
        CDB --> PDB2
        CDB --> PDB_SEED
    end

    %% Định nghĩa các class màu sắc
    classDef rootDB fill:#4CAF50,stroke:#2E7D32,stroke-width:3px,color:#FFFFFF
    classDef hrDB fill:#2196F3,stroke:#1565C0,stroke-width:2px,color:#FFFFFF
    classDef salesDB fill:#FF9800,stroke:#E65100,stroke-width:2px,color:#FFFFFF
    classDef seedDB fill:#9C27B0,stroke:#6A1B9A,stroke-width:2px,color:#FFFFFF
    
    %% Áp dụng màu cho các node
    class CDB rootDB
    class PDB1 hrDB
    class PDB2 salesDB
    class PDB_SEED seedDB

```

*   **Giải thích sơ đồ:**
    *   **Container Database (CDB):** Quản lý các tài nguyên chung (metadata, users chung).
    *   **Pluggable Database (PDB):** Là các CSDL độc lập chứa dữ liệu và đối tượng của từng ứng dụng. Chúng được "cắm" vào CDB.

### **2. Vận hành Cơ bản trong Môi trường RAC**

**Quy trình Khởi động (Startup) một CSDL RAC**

```mermaid
flowchart TD
    A[Bắt đầu] --> B{Đăng nhập vào server};
    B --> C[su - grid <br/> <i>Chuyển sang user 'grid'</i>];
    C --> D[crsctl stat res -t <br/> <i>Kiểm tra trạng thái Clusterware</i>];
    D --> E{Cluster đã chạy chưa?};
    E --Chưa--> F[crsctl start cluster <br/> <i>Khởi động Clusterware</i>];
    E --Rồi--> G[su - oracle <br/> <i>Chuyển sang user 'oracle'</i>];
    F --> G;
    G --> H[sqlplus / as sysdba <br/> <i>Kết nối vào SQL*Plus</i>];
    H --> I[startup <br/> <i>Khởi động Database Instance</i>];
    I --> J{PDB đã mở chưa?};
    J --Chưa--> K[alter pluggable database <br/> TÊN_PDB open;];
    K --> L[Kết thúc];
    J --Rồi--> L;

    %% Định nghĩa các class màu sắc
    classDef startEnd fill:#e1f5fe,stroke:#01579b,stroke-width:3px,color:#000
    classDef decision fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#000
    classDef gridUser fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    classDef oracleUser fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000
    classDef clusterOps fill:#fff8e1,stroke:#f57f17,stroke-width:2px,color:#000
    classDef dbOps fill:#fce4ec,stroke:#c2185b,stroke-width:2px,color:#000
    classDef pdbOps fill:#e0f2f1,stroke:#00695c,stroke-width:2px,color:#000

    %% Áp dụng màu sắc
    class A,L startEnd
    class B,E,J decision
    class C,D gridUser
    class G,H oracleUser
    class F clusterOps
    class I dbOps
    class K pdbOps

```

**Lệnh thực tế:**

1.  **Kiểm tra và khởi động Clusterware (với user `grid`):**
    ```bash
    su - grid
    crsctl stat res -t # Kiểm tra trạng thái
    # Nếu cần, khởi động: crsctl start cluster -all
    ```

2.  **Khởi động CSDL (với user `oracle`):**
    ```bash
    su - oracle
    sqlplus / as sysdba
    SQL> startup
    SQL> show pdbs; -- Kiểm tra trạng thái PDBs
    SQL> alter pluggable database all open; -- Mở tất cả PDBs
    ```

### **3. Giám sát và Chẩn đoán Hiệu năng**

**Quy trình Chẩn đoán một Vấn đề về Hiệu năng**

```mermaid
flowchart TD
    Start[Phát hiện hệ thống chậm] --> L1{"Lớp 1: Kiểm tra OS"};
    L1 --"OK"--> L2{"Lớp 2: Kiểm tra Storage (ASM)"};
    L1 --"Co van de"--> FixOS["Xử lý vấn đề OS <br/> (CPU/RAM cao, I/O wait)"];

    L2 --"OK"--> L3{"Lớp 3: Kiểm tra Database"};
    L2 --"Co van de"--> FixASM["Xử lý vấn đề Storage <br/> (Disk group đầy, lỗi disk)"];

    L3 --> S1["<b>Bước 1:</b> Tìm session 'ACTIVE' <br/> <i>(dùng gv$session)</i>"];
    S1 --> S2["Lấy ra <b>sql_id</b> và <b>last_call_et</b>"];
    S2 --> S3["<b>Bước 2:</b> Tìm nội dung câu lệnh <br/> <i>(dùng gv$sqlarea với sql_id)</i>"];
    S3 --> End["Tối ưu câu lệnh SQL <br/> (Thêm index, viết lại logic...)"]

    subgraph OSCommands ["Các lệnh kiểm tra OS"]
        direction LR
        top[top]
        free[free -g]
        iostat[iostat]
    end
    L1 --> OSCommands

    subgraph DBCommands ["Các lệnh kiểm tra DB"]
        direction LR
        q1[select ... from gv$session]
        q2[select ... from gv$sqlarea]
    end
    L3 --> DBCommands

    %% Định nghĩa các class màu sắc
    classDef startNode fill:#e1f5fe,stroke:#01579b,stroke-width:3px,color:#000
    classDef checkNode fill:#f3e5f5,stroke:#4a148c,stroke-width:2px,color:#000
    classDef fixNode fill:#ffebee,stroke:#b71c1c,stroke-width:2px,color:#000
    classDef processNode fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px,color:#000
    classDef endNode fill:#fff3e0,stroke:#e65100,stroke-width:3px,color:#000
    classDef commandNode fill:#f1f8e9,stroke:#33691e,stroke-width:1px,color:#000
    classDef subgraphStyle fill:#fafafa,stroke:#757575,stroke-width:2px

    %% Áp dụng class cho các node
    class Start startNode
    class L1,L2,L3 checkNode
    class FixOS,FixASM fixNode
    class S1,S2,S3 processNode
    class End endNode
    class top,free,iostat,q1,q2 commandNode
```

**Các câu lệnh SQL chẩn đoán:**

1.  **Bước 1: Tìm session đang chạy lâu và lấy `sql_id`**
    ```sql
    SELECT machine, schemaname, sql_id, last_call_et
    FROM gv$session
    WHERE status = 'ACTIVE' AND type != 'BACKGROUND'
    ORDER BY last_call_et DESC;
    ```
2.  **Bước 2: Lấy nội dung câu lệnh SQL từ `sql_id`**
    ```sql
    -- Thay ':your_sql_id' bằng sql_id bạn tìm được
    SELECT sql_fulltext
    FROM gv$sqlarea
    WHERE sql_id = ':your_sql_id';
    ```

---

## **Phần II: MongoDB**

### **1. Kiến trúc Sharding (Phân mảnh)**

Sharding là cách MongoDB phân tán dữ liệu ra nhiều máy chủ để xử lý khối lượng công việc khổng lồ.

```mermaid
graph TD
    App["Ứng dụng"] --> Mongos["Mongos Router"];

    subgraph "Metadata"
        Config["Config Servers<br/>(Lưu cấu hình Sharding)"]
    end

    subgraph "Data Storage"
        Shard1["Shard 1<br/>(Replica Set)"]
        Shard2["Shard 2<br/>(Replica Set)"]
        Shard3["Shard 3<br/>(Replica Set)"]
    end

    Mongos -- "Truy vấn & ghi dữ liệu" --> Shard1;
    Mongos -- "Truy vấn & ghi dữ liệu" --> Shard2;
    Mongos -- "Truy vấn & ghi dữ liệu" --> Shard3;
    Mongos -- "Đọc metadata" --> Config;

    %% Styling với nhiều màu sắc
    style App fill:#FF6B6B,stroke:#FF4757,stroke-width:3px,color:#fff
    style Mongos fill:#4ECDC4,stroke:#26D0CE,stroke-width:3px,color:#fff
    style Config fill:#FFE66D,stroke:#FFD93D,stroke-width:3px,color:#333
    style Shard1 fill:#A8E6CF,stroke:#7FCDCD,stroke-width:2px,color:#333
    style Shard2 fill:#88D8C0,stroke:#52C7B8,stroke-width:2px,color:#333
    style Shard3 fill:#6FCF97,stroke:#27AE60,stroke-width:2px,color:#333

    %% Styling cho subgraph
    classDef metadataGroup fill:#FFF5B4,stroke:#F39C12,stroke-width:2px
    classDef storageGroup fill:#E8F8F5,stroke:#16A085,stroke-width:2px
```

*   **Giải thích sơ đồ:**
    *   **Ứng dụng:** Chỉ cần biết và kết nối tới **Mongos**.
    *   **Mongos (Router):** Nhận truy vấn, hỏi **Config Servers** xem dữ liệu nằm ở đâu, sau đó chuyển truy vấn đến **Shard** tương ứng.
    *   **Config Servers:** Là "bộ não" của cluster, chứa bản đồ dữ liệu.
    *   **Shards:** Là các cụm replica set lưu trữ các phần dữ liệu đã được phân mảnh.

### **2. Vận hành và Giám sát**

#### **1. Quy trình Import dữ liệu vào Sharded Cluster**

```mermaid
flowchart TD
    Client["Client/Tool (mongoimport, Studio 3T...)"]
    
    subgraph "ĐÚNG"
        direction LR
        R1[Client] --> R2[Mongos] --> R3["Các Shard (Mongos tự điều phối)"]
    end

    subgraph "SAI"
        direction LR
        W1[Client] --> W2["Kết nối trực tiếp vào Shard 1"]
    end

    Client -- Nên làm --> R1
    Client -- Không nên làm --> W1

    style R2 fill:#9f9
    style W2 fill:#f66
```

> **Lưu ý quan trọng:** Luôn luôn thực hiện các thao tác (đọc, ghi, import...) thông qua **Mongos**. Việc import trực tiếp vào một Shard sẽ làm hỏng metadata và gây mất cân bằng dữ liệu nghiêm trọng trong cluster.

#### **2. Giám sát với MongoDB Compass**

MongoDB Compass là công cụ GUI trực quan để giám sát và quản lý MongoDB.

1.  Kết nối Compass đến địa chỉ của **Mongos**.
2.  Vào tab **Performance**.
3.  Tìm mục **Slowest Operations**.
    *   Mục này liệt kê các truy vấn chạy chậm nhất.
    *   Bạn có thể xem chi tiết câu lệnh (filter, projection), thời gian chạy, số document được quét (docsExamined) so với số document trả về (nReturned).
    *   Đây là điểm khởi đầu tuyệt vời để tìm ra truy vấn cần tối ưu (ví dụ: tạo index).